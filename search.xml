<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fedora38 KDE Plasma安装记录</title>
    <url>/blog/post/Fedora/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<p>我一直都想使用Linux系统，从Android的Termux到微软的WSL，一开始用Termux，但不能好好敲代码(手机那个键盘你敲一个试试?)。　　<br>
后来用WSL， 但我笔记本带不动WSl+Vscode， 就彻底放弃了…<br>
后来一直是Windows+Msys2+Vscode(安装ｃ库方便)，但后来使用xmake构建工程时发现vscode的xmake插件识别不到Msys2的xmake,碰巧寝室里有人玩双系统，就搞了。<br>
<br></p>
<h2 id="为什么是Fedora？"><a class="header-anchor" href="#为什么是Fedora？"></a>为什么是Fedora？</h2>
<p>我本就是想要一个统一的开发环境而已，显然任何Linux都可以达到我的需求，那为什么选Fedora(我室友在我耳边叨叨了Ubuntu好久)？<br>
原因是：我当天刚好看到了它，就这么简单。<br>
而且我没有用过Fedora，其他还算用过(Ubuntu WSL，Arch WSL)，Fedora是彻底没见过。<br>
而且Fedora有KDE定制版(KUbuntu：???)<br>
<em>BTW, Fuck you, Windows!</em><br>
<br></p>
<h2 id="开始安装"><a class="header-anchor" href="#开始安装"></a>开始安装</h2>
<h3 id="准备安装"><a class="header-anchor" href="#准备安装"></a>准备安装</h3>
<p>找一个不用的U盘，作为安装介质<br>
然后去官网下载安装 <a href="https://github.com/FedoraQt/MediaWriter/releases/tag/5.0.7">Fedora Media Writer</a>， 双击打开</p>
<p><img src="https://img1.imgtp.com/2023/09/16/MHZs4eVa.png" alt="Fedora Media Writer Home Page"></p>
<p>如图配置(当然你也可以自己下载对应镜像然后自己配置)</p>
<p><img src="https://img1.imgtp.com/2023/09/16/ylulVCpp.png" alt="Select Your OS Version"><br>
<img src="https://img1.imgtp.com/2023/09/16/Orscog1F.png" alt="Write Options"></p>
<p>然后等待它写入<br>
<br></p>
<h3 id="体验系统"><a class="header-anchor" href="#体验系统"></a>体验系统</h3>
<p>写入完成后，打开Windows设置 =&gt; Windows更新 =&gt; 恢复 =&gt; 高级启动 =&gt; 立即重新启动<br>
重启后，会进入高级启动界面，选择&quot;使用设备&quot;，然后选择&quot;Linpus lite&quot;，就会进入Grub2引导界面，选择第一个&quot;Start Fedora-KDE-Live 38&quot;，就会进入Fedora</p>
<details class="note info no-icon"><summary><p>题外话：关于 Lite系统</p>
</summary>
<p>使用Lite的目的是让用户得以在不安装完整系统的前提下较完整的体验操作系统，能让用户更好的做出是否安装的决定</p>
<p>详情见：<a href="https://fedoraproject.org/wiki/FedoraLiveCD/zh-cn">Fedora LiteCD</a></p>

</details>
<p>在体验过系统，确认需要安装后，双击桌面的&quot;Install to Hard Drive&quot;图标<br>
<br></p>
<h3 id="开始安装-v2"><a class="header-anchor" href="#开始安装-v2"></a>开始安装</h3>
<p>跟着安装引导做即可<br>
注意设置root用户的密码(你可以不使用root用户，但这样的话之后改Grub引导设置时会比较麻烦)</p>
<details class="note warning"><summary><p>关于双系统(Windows+Linux)</p>
</summary>
<p>第一是检查你的盘是否有BitLocker，若有，请务必解锁它！！！<br>
因为安装双系统后，你的盘大概率会被加密锁上，若你没有解锁，你是无法进入windows系统的！！！<br>
解锁方式是，在管理员模式下打开cmd，然后输入以下命令</p>
<pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">manage-bde -unlock &lt;你的盘&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>你可以输入  manage-bde -status 查看解锁状态<br>
请把所有盘都解锁，并且等待提示解锁完成，不然你绝对会后悔的！！！<br>
若你发现盘被锁了开不了，按下方提示解锁</p>
<ol>
<li>进入你电脑的bios界面，关闭安全启动</li>
<li>在另一台设备的浏览器转到 <a href="https://account.microsoft.com/devices/recoverykey">https://account.microsoft.com/devices/recoverykey</a> 登陆MS账户，找到恢复密钥</li>
<li>重新输入解锁命令，输入你找到的恢复密钥</li>
<li>等待解锁完成</li>
</ol>
<p>更多细节：<a href="https://learn.microsoft.com/zh-cn/windows-server/administration/windows-commands/manage-bde">manage-bde</a>，<a href="https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E6%9F%A5%E6%89%BE-bitlocker-%E6%81%A2%E5%A4%8D%E5%AF%86%E9%92%A5-6b71ad27-0b89-ea08-f143-056f5ab347d6">在 Windows 中查找 BitLocker 恢复密钥</a></p>

</details>
<p>到此基本安装就完成了<br>
<br></p>
<h2 id="修改引导"><a class="header-anchor" href="#修改引导"></a>修改引导</h2>
<p>现在系统安装好了，但默认还是进入Windows系统，需要修改引导<br>
进入你电脑的bios，找到启动菜单，把&quot;Fedora&quot;放到最上方(可能有两个，其中一个是rescue系统的，找以下就行)<br>
保存配置，重启电脑，就能看到Grub2的引导界面了<br>
<br></p>
<h2 id="换源"><a class="header-anchor" href="#换源"></a>换源</h2>
<p>这是国内使用Linux发行版老生常谈的问题了，直接换镜像<a href="https://mirrors.tuna.tsinghua.edu.cn/help/fedora/">(清华镜像帮助)</a></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">'s|^metalink=|#metalink=|g'</span> <span class="token punctuation">\</span>
         <span class="token parameter variable">-e</span> <span class="token string">'s|^#baseurl=http://download.example/pub/fedora/linux|baseurl=https://mirrors.tuna.tsinghua.edu.cn/fedora|g'</span> <span class="token punctuation">\</span>
         <span class="token parameter variable">-i.bak</span> <span class="token punctuation">\</span>
         /etc/yum.repos.d/fedora.repo <span class="token punctuation">\</span>
         /etc/yum.repos.d/fedora-modular.repo <span class="token punctuation">\</span>
         /etc/yum.repos.d/fedora-updates.repo <span class="token punctuation">\</span>
         /etc/yum.repos.d/fedora-updates-modular.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>OK，现在dnf速度就快了<br>
<br></p>
<h2 id="安装软件"><a class="header-anchor" href="#安装软件"></a>安装软件</h2>
<p>接下来就是Linux的传统了<br>
<strong>包管理器，启动！！！</strong></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开发环境配置</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> gcc                    <span class="token comment"># gnu toolchain</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> llvm                   <span class="token comment"># llvm toolchain</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> clang                  <span class="token comment"># clang</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> clang-tools-extra      <span class="token comment"># clang tools, such as clangd</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> cmake                  <span class="token comment"># cmake</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> <span class="token punctuation">..</span>.

<span class="token comment"># 安装VScode</span>
<span class="token comment"># 添加 VScode 源</span>
<span class="token function">sudo</span> <span class="token function">rpm</span> <span class="token parameter variable">--import</span> https://packages.microsoft.com/keys/microsoft.asc

<span class="token comment"># 添加 VScode 存储库到系统</span>
<span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/vscode.repo <span class="token operator">&lt;&lt;&lt;</span><span class="token string">'[code]
name=Visual Studio Code
baseurl=https://packages.microsoft.com/yumrepos/vscode
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc'</span>

<span class="token comment"># 安装 VScode</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> code

<span class="token comment"># flatpak 解禁</span>
<span class="token function">sudo</span> flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

<span class="token comment"># 安装各类浏览器</span>
<span class="token function">sudo</span> flatpak <span class="token function">install</span> org.chromium.Chromium
<span class="token function">sudo</span> flatpak <span class="token function">install</span> com.microsoft.Edge

<span class="token comment"># 安装 QQ</span>
<span class="token function">sudo</span> flatpak <span class="token function">install</span> com.qq.QQ

<span class="token comment"># 安装 Xmake</span>
<span class="token function">wget</span> https://xmake.io/shget.text <span class="token parameter variable">-O</span> - <span class="token operator">|</span> <span class="token function">bash</span>

<span class="token comment"># 安装 zsh</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> <span class="token function">zsh</span>

<span class="token comment"># zsh 美化，使用Prezto</span>
<span class="token function">zsh</span>

<span class="token function">git</span> clone <span class="token parameter variable">--recursive</span> https://github.com/sorin-ionescu/prezto.git <span class="token string">"<span class="token variable">$&#123;ZDOTDIR<span class="token operator">:-</span>$HOME&#125;</span>/.zprezto"</span>

setopt EXTENDED_GLOB
<span class="token keyword">for</span> <span class="token for-or-select variable">rcfile</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$&#123;ZDOTDIR<span class="token operator">:-</span>$HOME&#125;</span>"</span>/.zprezto/runcoms/^README.md<span class="token punctuation">(</span>.N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token function">ln</span> <span class="token parameter variable">-s</span> <span class="token string">"<span class="token variable">$rcfile</span>"</span> <span class="token string">"<span class="token variable">$&#123;ZDOTDIR<span class="token operator">:-</span>$HOME&#125;</span>/.<span class="token variable">$&#123;rcfile<span class="token operator">:</span>t&#125;</span>"</span>
<span class="token keyword">done</span>

chsh <span class="token parameter variable">-s</span> /bin/zsh
<span class="token comment"># zprezto 配置请去github(https://github.com/sorin-ionescu/prezto)自己研究</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在Fedora已经可以满足使用要求了<br>
<br></p>
<h2 id="疑难杂症"><a class="header-anchor" href="#疑难杂症"></a>疑难杂症</h2>
<h3 id="视频解码"><a class="header-anchor" href="#视频解码"></a>视频解码</h3>
<p>当你以为可以开心体验系统，准备打开B站放松以下时，你会发现：<br>
？？？加载不出来？？？</p>
<p>若你有一定的经验，当你按 <kbd>F12</kbd> 打开开发者工具，到控制台下找原因时，你会发现：<br>
？？？无法解析媒体文件？？？</p>
<p>这是因为现在大多数的流媒体使用H264解析，但H264是<strong>不开源</strong>的，所以Fedora不会内置H264解析器，需要自己安装解析器<br>
你可以直接安装ffmpeg，这会自动安装OpenH264(H264的社区开源版本)</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dnf <span class="token function">install</span> ffmpeg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>但是</strong><br>
若你在国内，访问OpenH264的repo的速度奇慢无比，以至于dnf告诉你没有可用镜像<br>
怎么办？<br>
在dnf运行时，它会告诉你它在尝试连接哪个repo的地址，把地址记下来，在其他设备上挂梯子把地址指向的.rmp包文件下下来<br>
然后把包文件传到电脑上，接着：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dnf <span class="token function">install</span> <span class="token operator">&lt;</span>你的包<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>若提示缺少依赖，就用同样的方法把依赖下下来，装好，然后在装需要依赖的包</p>
<p>不过，这样也只是解决了一部分视频解码的问题，若要支持全部视频解码，需要安装所有解码器</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启用 RPM Fusion 库，支持视频解码</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-<span class="token variable"><span class="token variable">$(</span><span class="token function">rpm</span> <span class="token parameter variable">-E</span> %fedora<span class="token variable">)</span></span>.noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-<span class="token variable"><span class="token variable">$(</span><span class="token function">rpm</span> <span class="token parameter variable">-E</span> %fedora<span class="token variable">)</span></span>.noarch.rpm

<span class="token comment"># 安装所有解码器</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> gstreamer1-plugins-<span class="token punctuation">&#123;</span>bad-<span class="token punctuation">\</span>*,good-<span class="token punctuation">\</span>*,base<span class="token punctuation">&#125;</span> gstreamer1-plugin-openh264 gstreamer1-libav <span class="token parameter variable">--exclude</span><span class="token operator">=</span>gstreamer1-plugins-bad-free-devel

<span class="token comment"># 你可以安装视频播放器来支持解码</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> vlc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>OK，现在可以愉快看B站鬼畜了(误)<br>
<br></p>
<h3 id="中文输入"><a class="header-anchor" href="#中文输入"></a>中文输入</h3>
<p>这是也是国内使用Linux发行版老生常谈的问题了，使用Fcitx5+词库解决</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装Fcitx5和中文插件，以及切换输入法工具</span>
<span class="token function">sudo</span> dnf <span class="token function">install</span> fcitx5
<span class="token function">sudo</span> dnf <span class="token function">install</span> fcitx5-chinese-addons
<span class="token function">sudo</span> dnf <span class="token function">install</span> im-chooser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在终端输入<code>im-chooser</code>切换为fcitx5输入法，注销重进系统<br>
在底下的状态栏找到输入法托盘图标，右击选择配置，在 “可用输入法&quot;中找到&quot;拼音”，添加到&quot;当前输入法&quot;中<br>
现在可以输入中文了，但联想非常拉胯<br>
在&quot;当前输入法&quot;中选择&quot;拼音&quot;，点击中间的&quot;配置&quot;，下拉找到&quot;管理字典&quot;，选择&quot;导入&quot;，“从文件”，导入.txt格式的字典文件<br>
若你有.scel格式的搜狗字典文件，可以选择&quot;来自搜狗细胞词库的文件&quot;来导入字典<br>
字典文件可以在网上搜到，这里推荐一个<a href="https://github.com/thunlp/THUOCL/tree/master">THUOCL清华词库</a>，质量高，好用<br>
若需要<a href="https://wwqe.lanzouy.com/b04wily4j">搜狗词库</a>，自取，密码:e570<br>
<br></p>
<h3 id="网络连接"><a class="header-anchor" href="#网络连接"></a>网络连接</h3>
<p>众所周知，<a href="https://wiki.mbalib.com/wiki/GFW">GFW</a>导致国内访问github困难，所以梯子是必备的<br>
不详细说明了，直接贴连接吧： <a href="https://github.com/wanhebin/clash-for-linux">https://github.com/wanhebin/clash-for-linux</a><br>
<br></p>
<h2 id="结语"><a class="header-anchor" href="#结语"></a>结语</h2>
<p>折腾了两天，在网络资源和室友的帮助下搞好了Fedora，Fedora的软件支持确实比Ubuntu少的多，而且问题也多，但折腾的过程很享受<br>
不得不说，笔记本用Linux确实比Windows好，Windows开机就占了8GB内存，Linux只占3GB，使用也只占不到5GB，LinuxNB！！！<br>
但这都是在我不玩游戏只搞开发的前提下，如果想打游戏，Linux的兼容会让你想死，所以还是用Windows吧。</p>
]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
        <tag>KDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog Test</title>
    <url>/blog/post/math-func/</url>
    <content><![CDATA[<div class="tabs" id="fourth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fourth-unique-name-1">Solution 1</a></li><li class="tab"><a href="#fourth-unique-name-2">Solution 2</a></li><li class="tab"><a href="#fourth-unique-name-3">Solution 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="fourth-unique-name-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-pane" id="fourth-unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div>
<div id="chart1" style="width: 100%;height:600px;"></div>
<script type="text/javascript" src="/blog/scripts/dark.js"></script>
<script type="text/javascript" src="/blog/scripts/post/chart1.js"></script>
<br>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言学习记录第一弹</title>
    <url>/blog/post/c-study1/</url>
    <content><![CDATA[<p>我在翻阅 <a href="https://zh.cppreference.com/w/c/language/translation_phases">C Refernce</a> 的&quot;翻译阶段3&quot;时，注意到&quot;<ins>最大吞噬</ins>&quot;原则:</p>
<blockquote>
<p>若已经分析输入为到给定字符为止的预处理记号，则通常将能构成一个预处理记号的最长字符序列处理成下个预处理记号，即这会导致后继分析失败。这常被称为最大吞噬 (maximal munch) 。</p>
</blockquote>
<p>“<ins>最大吞噬</ins>&quot;原则指出: 编译器会尽可能把能识别成一个预处理记号的多义记号处理成一个记号<br>
类似正则表达式中的&quot;贪婪匹配”</p>
<div class="note info no-icon"><p>例: <code>a+++++b</code> 译为 <code>a++ ++ +b</code> 而不是 <code>a++ + ++b</code></p>
</div>
<p>根据定义与官方示例, 做以下实验:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// main.c</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0xE</span><span class="token operator">+</span>b<span class="token punctuation">;</span>        <span class="token comment">//! 错误：整数常量的“+b”后缀无效, 编译无法通过</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0xE</span> <span class="token operator">+</span> b<span class="token punctuation">;</span>      <span class="token comment">//  正常: 编译通过</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0xF</span><span class="token operator">+</span>b<span class="token punctuation">;</span>        <span class="token comment">//  正常: 编译通过</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一行: 因为E在数字中可以表示科学计数法(如1E10, 2E+2, 1.5E-3), 所以编译器处理&quot;0xE+b&quot;时会将它们放在一起, 导致编译出错。<br>
第二行: 使用空格可以分解预处理记号。<br>
第三行: “0xF&quot;是单义的, 编译器不会把它和”+b&quot;放在一起。</p>
<p>由此可知, 编译器对符号的处理是以字符为基础单位的, 而不是一个逻辑行。<br>
它无法分辨符号的含义, 它不知道&quot;0xE&quot;是一个整体, 它也不知道&quot;E&quot;后面的&quot;+&quot;不是后缀而是加法运算符, 虽然我们一眼就可以看出, 但编译器做不到。</p>
<p>事实上, 上述程序在编译经历5个阶段:</p>
<ol>
<li>源码输入</li>
<li>词法分析, 产生词素</li>
<li>语法分析, 产生语法树</li>
<li>语义分析, 校验语法树, 产生解析树</li>
<li>中间代码生成</li>
</ol>
<p>而 C 编译器则由以下几个部分构成:</p>
<ol>
<li>预处理器</li>
<li>编译器</li>
<li>汇编器</li>
<li>链接器</li>
</ol>
<p>若在编译时加上<code>--save-temp</code>, 编译器就会保留期间产生的中间代码<br>
其中<code>.i</code>文件为预处理器运行后生成的文件, <code>.s</code>为编译器, <code>.o</code>为汇编器, <code>.out/.exe</code>为最终产物(链接器)<br>
实验程序的预处理如下:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// main.i</span>

# <span class="token number">0</span> <span class="token string">"main.c"</span>
# <span class="token number">0</span> <span class="token string">"&lt;built-in>"</span>
# <span class="token number">0</span> <span class="token string">"&lt;命令行>"</span>
# <span class="token number">1</span> <span class="token string">"/usr/include/stdc-predef.h"</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">4</span>
# <span class="token number">0</span> <span class="token string">"&lt;命令行>"</span> <span class="token number">2</span>
# <span class="token number">1</span> <span class="token string">"main.c"</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0xE</span><span class="token operator">+</span>b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0xE</span> <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0xF</span><span class="token operator">+</span>b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译器结果如下:</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;&#x2F; main.s

&#x2F;&#x2F; 这是结果
	.file	&quot;main.c&quot;

&#x2F;&#x2F; 正常长这样
	.file	&quot;main.c&quot;
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	addl	$14, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$15, %eax
	movl	%eax, -8(%rbp)
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	&quot;GCC: (GNU) 13.2.1 20230728 (Red Hat 13.2.1-1)&quot;
	.section	.note.GNU-stack,&quot;&quot;,@progbits<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到编译器输出异常了, 编译器只是加载了文件, 没有生成代码 ,也就是在编译阶段出错了。<br>
使用<code>--verbose</code>也可以发现问题:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 忽略gcc参数配置</span>

<span class="token comment"># 预处理开始</span>
<span class="token comment">#include "..." 搜索从这里开始：</span>
<span class="token comment">#include &lt;...> 搜索从这里开始：</span>
 /usr/lib/gcc/x86_64-redhat-linux/13/include
 /usr/local/include
 /usr/include
搜索列表结束。
<span class="token comment"># 预处理结束</span>

<span class="token comment"># 编译开始</span>
Compiler executable checksum: 5eaad519de86376ffacf24afdb40da84
<span class="token comment"># 编译结束, 是的, 它只给你看个hash</span>

<span class="token comment"># 错误信息</span>
main.c: 在函数‘main’中:
main.c:2:13: 错误：整数常量的“+b”后缀无效
    <span class="token number">2</span> <span class="token operator">|</span>     int a <span class="token operator">=</span> 0xE+b<span class="token punctuation">;</span>
      <span class="token operator">|</span>             ^~~~~

<span class="token comment"># 接下来是后续正常的情况</span>

<span class="token comment"># 忽略gcc汇编参数, 汇编开始</span>
GNU assembler version <span class="token number">2.39</span> <span class="token punctuation">(</span>x86_64-redhat-linux<span class="token punctuation">)</span> using BFD version version <span class="token number">2.39</span>-9.fc38
<span class="token comment"># 汇编结束</span>

<span class="token comment"># 链接</span>
<span class="token assign-left variable">COMPILER_PATH</span><span class="token operator">=</span>/usr/libexec/gcc/x86_64-redhat-linux/13/:/usr/libexec/gcc/x86_64-redhat-linux/13/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/13/:/usr/lib/gcc/x86_64-redhat-linux/
<span class="token assign-left variable">LIBRARY_PATH</span><span class="token operator">=</span>/usr/lib/gcc/x86_64-redhat-linux/13/:/usr/lib/gcc/x86_64-redhat-linux/13/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/lib64/:/lib/<span class="token punctuation">..</span>/lib64/:/usr/lib/<span class="token punctuation">..</span>/lib64/:/usr/lib/gcc/x86_64-redhat-linux/13/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/:/lib/:/usr/lib/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结合翻译阶段来看, 可以发现是第三阶段时将&quot;0xE+b&quot;视为一个整体, 第七阶段编译进行到第三阶段产生语法树时发现不对了, 于是报错。</p>
<p>由此可见, 在运算符两旁加空格不仅是为了美观, <strong>更是为了避免因&quot;最大吞噬&quot;导致的编译错误</strong>。</p>
<p>所以各位, 代码一定要美观啊! 要不然连编译器都受不了了报错啊！</p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>学习</tag>
        <tag>实验</tag>
      </tags>
  </entry>
</search>
